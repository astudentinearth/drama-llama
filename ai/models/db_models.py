from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Float, JSON, Boolean, Enum as SQLEnum
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime
import enum

Base = declarative_base()


class SkillLevelEnum(str, enum.Enum):
    """Skill proficiency levels."""
    BEGINNER = "beginner"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"
    EXPERT = "expert"


class RoadmapStatusEnum(str, enum.Enum):
    """Roadmap status types."""
    DRAFT = "draft"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    ARCHIVED = "archived"


class SessionStatusEnum(str, enum.Enum):
    """Session status types."""
    ACTIVE = "active"
    COMPLETED = "completed"
    ARCHIVED = "archived"


class Session(Base):
    """
    Session model that groups related roadmaps and learning materials.
    Users interact with sessions, and each session contains its associated roadmap.
    This allows users to have multiple learning sessions/journeys.
    User management is handled by the main backend - we only store user_id references.
    """
    __tablename__ = "sessions"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(String(255), nullable=False, index=True)  # Reference to user in main backend
    
    # Session details
    session_name = Column(String(500))  # Optional user-defined name
    description = Column(Text)  # Optional description

    # Messages
    messages = Column(JSON)  # List of messages
    
    # Status
    status = Column(SQLEnum(SessionStatusEnum), default=SessionStatusEnum.ACTIVE)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    completed_at = Column(DateTime, nullable=True)
    
    # Relationships
    roadmap = relationship("Roadmap", back_populates="session", uselist=False, cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<Session(id={self.id}, user_id={self.user_id}, status={self.status})>"


class Roadmap(Base):
    """
    Stores roadmap skeleton generated by createRoadmapSkeleton.
    Contains the overall roadmap structure with goals and graduation project.
    Now bound to a Session rather than directly to a User.
    """
    __tablename__ = "roadmaps"
    
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(Integer, ForeignKey("sessions.id", ondelete="CASCADE"), nullable=False, index=True, unique=True)
    
    # Input data
    user_request = Column(Text, nullable=False)
    user_summarized_cv = Column(Text)
    user_expertise_domains = Column(JSON)  # List of domains
    job_listings = Column(JSON)  # List of job listing texts/URLs
    
    # Generated data
    total_estimated_weeks = Column(Integer)
    graduation_project = Column(Text)
    graduation_project_title = Column(String(500))
    graduation_project_requirements = Column(JSON)  # List of requirements
    graduation_project_estimated_hours = Column(Integer)
    
    # Metadata
    status = Column(SQLEnum(RoadmapStatusEnum), default=RoadmapStatusEnum.DRAFT)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    completed_at = Column(DateTime, nullable=True)
    
    # Relationships
    session = relationship("Session", back_populates="roadmap")
    goals = relationship("RoadmapGoal", back_populates="roadmap", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<Roadmap(id={self.id}, session_id={self.session_id}, status={self.status})>"


class RoadmapGoal(Base):
    """
    Stores individual goals/things-to-learn from the roadmap.
    Each goal represents a learning objective in the roadmap.
    """
    __tablename__ = "roadmap_goals"
    
    id = Column(Integer, primary_key=True, index=True)
    roadmap_id = Column(Integer, ForeignKey("roadmaps.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Goal details
    goal_number = Column(Integer, nullable=False)  # Order in the roadmap
    title = Column(String(500), nullable=False)
    description = Column(Text, nullable=False)
    priority = Column(Integer, default=3)  # 1-5 scale
    skill_level = Column(SQLEnum(SkillLevelEnum), default=SkillLevelEnum.BEGINNER)
    
    # Time estimation
    estimated_hours = Column(Integer)
    actual_hours_spent = Column(Integer, default=0)
    
    # Prerequisites
    prerequisites = Column(JSON)  # List of prerequisite skills/goals
    
    # Progress tracking
    is_completed = Column(Boolean, default=False)
    completion_percentage = Column(Float, default=0.0)
    started_at = Column(DateTime, nullable=True)
    completed_at = Column(DateTime, nullable=True)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    
    # Relationships
    roadmap = relationship("Roadmap", back_populates="goals")
    learning_materials = relationship("LearningMaterial", back_populates="goal", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<RoadmapGoal(id={self.id}, title={self.title}, completed={self.is_completed})>"


class LearningMaterial(Base):
    """
    Stores learning materials generated by createLearningMaterials.
    Contains curated resources, tutorials, and content for each goal.
    Each learning material is associated with a specific roadmap goal.
    """
    __tablename__ = "learning_materials"
    
    id = Column(Integer, primary_key=True, index=True)
    goal_id = Column(Integer, ForeignKey("roadmap_goals.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Material content
    material_type = Column(String(100))  # e.g., "article", "video", "tutorial", "course", "documentation"
    title = Column(String(500), nullable=False)
    content = Column(Text)  # Generated or scraped content
    source_url = Column(Text)  # Original URL if scraped
    
    # Material details
    description = Column(Text)
    estimated_time_minutes = Column(Integer)
    difficulty_level = Column(SQLEnum(SkillLevelEnum))
    
    # End of material project
    end_of_material_project = Column(Text)  # Small project to practice the learned material
    project_requirements = Column(JSON)  # List of project requirements
    
    # Quality metrics
    relevance_score = Column(Float)  # How relevant to the goal (0-1)
    quality_score = Column(Float)  # Overall quality score (0-1)
    
    # Progress tracking
    is_completed = Column(Boolean, default=False)
    user_rating = Column(Integer)  # User feedback (1-5)
    user_notes = Column(Text)  # User's personal notes
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    completed_at = Column(DateTime, nullable=True)
    
    # Relationships
    goal = relationship("RoadmapGoal", back_populates="learning_materials")
    
    def __repr__(self):
        return f"<LearningMaterial(id={self.id}, goal_id={self.goal_id}, title={self.title}, type={self.material_type})>"

class UserSkill(Base):
    """
    Stores user's skills extracted from CV and updated through progress.
    Helps in personalizing roadmaps and tracking skill development.
    User management is handled by the main backend - we only store user_id references.
    """
    __tablename__ = "user_skills"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=False, index=True)  # Reference to user in main backend
    
    # Skill details
    skill_name = Column(String(200), nullable=False)
    skill_level = Column(SQLEnum(SkillLevelEnum), default=SkillLevelEnum.BEGINNER)
    confidence_score = Column(Float, default=0.8)  # 0-1 scale
    
    # Source
    source = Column(String(100))  # "cv", "course_completion", "self_reported", "assessment"
    verified = Column(Boolean, default=False)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    
    def __repr__(self):
        return f"<UserSkill(user_id={self.user_id}, skill={self.skill_name}, level={self.skill_level})>"


class QuestionDifficultyEnum(str, enum.Enum):
    """Question difficulty levels."""
    INTRODUCTORY = "introductory"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"


class GraduationProjectQuestion(Base):
    """
    Stores open-ended questions generated for graduation project assessment.
    Each question tests competencies across the roadmap goals and materials.
    """
    __tablename__ = "graduation_project_questions"
    
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(Integer, ForeignKey("sessions.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Question identification
    question_id = Column(String(255), nullable=False, unique=True)  # Stable slug (kebab-case)
    
    # Question content
    prompt = Column(Text, nullable=False)  # The actual question text
    rationale = Column(Text, nullable=False)  # Why this question assesses the competency
    
    # Coverage mapping
    goals_covered = Column(JSON, nullable=False)  # Array of goal IDs
    materials_covered = Column(JSON, nullable=False)  # Array of material IDs
    expected_competencies = Column(JSON, nullable=False)  # Array of competency strings
    
    # Question metadata
    difficulty = Column(SQLEnum(QuestionDifficultyEnum), nullable=False)
    estimated_time_minutes = Column(Integer, nullable=False)
    
    # Evaluation criteria
    evaluation_rubric = Column(JSON, nullable=False)  # Array of criterion strings
    answer_min_chars = Column(Integer, nullable=False, default=500)
    answer_max_chars = Column(Integer, nullable=False, default=2500)
    requires_material_citations = Column(Boolean, nullable=False, default=False)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    
    # Relationships
    submissions = relationship("GraduationProjectSubmission", back_populates="question", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<GraduationProjectQuestion(id={self.id}, question_id={self.question_id}, difficulty={self.difficulty})>"


class GraduationProjectSubmission(Base):
    """
    Stores user submissions for graduation project questions.
    Each submission contains the user's answer and optional citations from materials.
    """
    __tablename__ = "graduation_project_submissions"
    
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(Integer, ForeignKey("sessions.id", ondelete="CASCADE"), nullable=False, index=True)
    question_id = Column(Integer, ForeignKey("graduation_project_questions.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Submission content
    answer_text = Column(Text, nullable=False)
    citations = Column(JSON)  # Array of {material_id, excerpt} objects
    
    # Evaluation results (populated by AI evaluation)
    evaluation_score = Column(Float)  # 0-1 scale
    evaluation_feedback = Column(Text)  # AI-generated feedback
    rubric_scores = Column(JSON)  # Per-criterion scores
    
    # Metadata
    submitted_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    evaluated_at = Column(DateTime, nullable=True)
    
    # Relationships
    question = relationship("GraduationProjectQuestion", back_populates="submissions")
    
    def __repr__(self):
        return f"<GraduationProjectSubmission(id={self.id}, question_id={self.question_id}, session_id={self.session_id})>"
