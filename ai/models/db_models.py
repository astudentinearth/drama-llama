from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Float, JSON, Boolean, Enum as SQLEnum
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime
import enum

Base = declarative_base()


class SkillLevelEnum(str, enum.Enum):
    """Skill proficiency levels."""
    BEGINNER = "beginner"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"
    EXPERT = "expert"


class RoadmapStatusEnum(str, enum.Enum):
    """Roadmap status types."""
    DRAFT = "draft"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    ARCHIVED = "archived"


class SessionStatusEnum(str, enum.Enum):
    """Session status types."""
    ACTIVE = "active"
    COMPLETED = "completed"
    ARCHIVED = "archived"


class Session(Base):
    """
    Session model that groups related roadmaps and learning materials.
    Users interact with sessions, and each session contains its associated roadmap.
    This allows users to have multiple learning sessions/journeys.
    User management is handled by the main backend - we only store user_id references.
    """
    __tablename__ = "sessions"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(String(255), nullable=False, index=True)  # Reference to user in main backend
    
    # Session details
    session_name = Column(String(500))  # Optional user-defined name
    description = Column(Text)  # Optional description

    # Messages
    messages = Column(JSON)  # List of messages
    
    # Status
    status = Column(SQLEnum(SessionStatusEnum), default=SessionStatusEnum.ACTIVE)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    completed_at = Column(DateTime, nullable=True)
    
    # Relationships
    roadmap = relationship("Roadmap", back_populates="session", uselist=False, cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<Session(id={self.id}, user_id={self.user_id}, status={self.status})>"


class Roadmap(Base):
    """
    Stores roadmap skeleton generated by createRoadmapSkeleton.
    Contains the overall roadmap structure with goals and graduation project.
    Now bound to a Session rather than directly to a User.
    """
    __tablename__ = "roadmaps"
    
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(Integer, ForeignKey("sessions.id", ondelete="CASCADE"), nullable=False, index=True, unique=True)
    
    # Input data
    user_request = Column(Text, nullable=False)
    user_summarized_cv = Column(Text)
    user_expertise_domains = Column(JSON)  # List of domains
    job_listings = Column(JSON)  # List of job listing texts/URLs
    
    # Generated data
    total_estimated_weeks = Column(Integer)
    graduation_project = Column(Text)
    graduation_project_title = Column(String(500))
    graduation_project_requirements = Column(JSON)  # List of requirements
    graduation_project_estimated_hours = Column(Integer)
    
    # Metadata
    status = Column(SQLEnum(RoadmapStatusEnum), default=RoadmapStatusEnum.DRAFT)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    completed_at = Column(DateTime, nullable=True)
    
    # Relationships
    session = relationship("Session", back_populates="roadmap")
    goals = relationship("RoadmapGoal", back_populates="roadmap", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<Roadmap(id={self.id}, session_id={self.session_id}, status={self.status})>"


class RoadmapGoal(Base):
    """
    Stores individual goals/things-to-learn from the roadmap.
    Each goal represents a learning objective in the roadmap.
    """
    __tablename__ = "roadmap_goals"
    
    id = Column(Integer, primary_key=True, index=True)
    roadmap_id = Column(Integer, ForeignKey("roadmaps.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Goal details
    goal_number = Column(Integer, nullable=False)  # Order in the roadmap
    title = Column(String(500), nullable=False)
    description = Column(Text, nullable=False)
    priority = Column(Integer, default=3)  # 1-5 scale
    skill_level = Column(SQLEnum(SkillLevelEnum), default=SkillLevelEnum.BEGINNER)
    
    # Time estimation
    estimated_hours = Column(Integer)
    actual_hours_spent = Column(Integer, default=0)
    
    # Prerequisites
    prerequisites = Column(JSON)  # List of prerequisite skills/goals
    
    # Progress tracking
    is_completed = Column(Boolean, default=False)
    completion_percentage = Column(Float, default=0.0)
    started_at = Column(DateTime, nullable=True)
    completed_at = Column(DateTime, nullable=True)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    
    # Relationships
    roadmap = relationship("Roadmap", back_populates="goals")
    learning_materials = relationship("LearningMaterial", back_populates="goal", cascade="all, delete-orphan")
    quizzes = relationship("Quiz", back_populates="goal", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<RoadmapGoal(id={self.id}, title={self.title}, completed={self.is_completed})>"


class LearningMaterial(Base):
    """
    Stores learning materials generated by createLearningMaterials.
    Contains curated resources, tutorials, and content for each goal.
    Each learning material is associated with a specific roadmap goal.
    """
    __tablename__ = "learning_materials"
    
    id = Column(Integer, primary_key=True, index=True)
    goal_id = Column(Integer, ForeignKey("roadmap_goals.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Material content
    material_type = Column(String(100))  # e.g., "article", "video", "tutorial", "course", "documentation"
    title = Column(String(500), nullable=False)
    content = Column(Text)  # Generated or scraped content
    source_url = Column(Text)  # Original URL if scraped
    
    # Material details
    description = Column(Text)
    estimated_time_minutes = Column(Integer)
    difficulty_level = Column(SQLEnum(SkillLevelEnum))
    
    # End of material project
    end_of_material_project = Column(Text)  # Small project to practice the learned material
    project_requirements = Column(JSON)  # List of project requirements
    
    # Quality metrics
    relevance_score = Column(Float)  # How relevant to the goal (0-1)
    quality_score = Column(Float)  # Overall quality score (0-1)
    
    # Progress tracking
    is_completed = Column(Boolean, default=False)
    user_rating = Column(Integer)  # User feedback (1-5)
    user_notes = Column(Text)  # User's personal notes
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    completed_at = Column(DateTime, nullable=True)
    
    # Relationships
    goal = relationship("RoadmapGoal", back_populates="learning_materials")
    
    def __repr__(self):
        return f"<LearningMaterial(id={self.id}, goal_id={self.goal_id}, title={self.title}, type={self.material_type})>"

class UserSkill(Base):
    """
    Stores user's skills extracted from CV and updated through progress.
    Helps in personalizing roadmaps and tracking skill development.
    User management is handled by the main backend - we only store user_id references.
    """
    __tablename__ = "user_skills"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=False, index=True)  # Reference to user in main backend
    
    # Skill details
    skill_name = Column(String(200), nullable=False)
    skill_level = Column(SQLEnum(SkillLevelEnum), default=SkillLevelEnum.BEGINNER)
    confidence_score = Column(Float, default=0.8)  # 0-1 scale
    
    # Source
    source = Column(String(100))  # "cv", "course_completion", "self_reported", "assessment"
    verified = Column(Boolean, default=False)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    
    def __repr__(self):
        return f"<UserSkill(user_id={self.user_id}, skill={self.skill_name}, level={self.skill_level})>"


class QuestionDifficultyEnum(str, enum.Enum):
    """Question difficulty levels."""
    INTRODUCTORY = "introductory"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"


class GraduationProjectQuestion(Base):
    """
    Stores open-ended questions generated for graduation project assessment.
    Each question tests competencies across the roadmap goals and materials.
    """
    __tablename__ = "graduation_project_questions"
    
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(Integer, ForeignKey("sessions.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Question identification
    question_id = Column(String(255), nullable=False, unique=True)  # Stable slug (kebab-case)
    
    # Question content
    prompt = Column(Text, nullable=False)  # The actual question text
    rationale = Column(Text, nullable=False)  # Why this question assesses the competency
    
    # Coverage mapping
    goals_covered = Column(JSON, nullable=False)  # Array of goal IDs
    materials_covered = Column(JSON, nullable=False)  # Array of material IDs
    expected_competencies = Column(JSON, nullable=False)  # Array of competency strings
    
    # Question metadata
    difficulty = Column(SQLEnum(QuestionDifficultyEnum), nullable=False)
    estimated_time_minutes = Column(Integer, nullable=False)
    
    # Evaluation criteria
    evaluation_rubric = Column(JSON, nullable=False)  # Array of criterion strings
    answer_min_chars = Column(Integer, nullable=False, default=500)
    answer_max_chars = Column(Integer, nullable=False, default=2500)
    requires_material_citations = Column(Boolean, nullable=False, default=False)
    
    # Relationships
    submissions = relationship("GraduationProjectSubmission", back_populates="question", cascade="all, delete-orphan")


class GraduationProjectSubmission(Base):
    """
    Stores user submissions for graduation project questions.
    Each submission contains the user's answer and optional citations from materials.
    """
    __tablename__ = "graduation_project_submissions"
    
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(Integer, ForeignKey("sessions.id", ondelete="CASCADE"), nullable=False, index=True)
    question_id = Column(Integer, ForeignKey("graduation_project_questions.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Submission content
    answer_text = Column(Text, nullable=False)
    citations = Column(JSON)  # Array of {material_id, excerpt} objects
    
    # Evaluation results (populated by AI evaluation)
    evaluation_score = Column(Float)  # 0-1 scale
    evaluation_feedback = Column(Text)  # AI-generated feedback
    rubric_scores = Column(JSON)  # Per-criterion scores
    
    # Metadata
    submitted_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    evaluated_at = Column(DateTime, nullable=True)
    
    # Relationships
    question = relationship("GraduationProjectQuestion", back_populates="submissions")
    
    def __repr__(self):
        return f"<GraduationProjectSubmission(id={self.id}, question_id={self.question_id}, session_id={self.session_id})>"


class Quiz(Base):
    """
    Stores quiz information generated for specific learning goals.
    Each quiz is associated with a roadmap goal and contains multiple questions.
    """
    __tablename__ = "quizzes"
    
    id = Column(Integer, primary_key=True, index=True)
    goal_id = Column(Integer, ForeignKey("roadmap_goals.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Quiz details
    title = Column(String(500), nullable=False)
    description = Column(Text)
    
    # Quiz settings
    time_limit_minutes = Column(Integer)  # Optional time limit
    passing_score_percentage = Column(Float, default=70.0)  # Default 70% to pass
    max_attempts = Column(Integer, default=3)  # Maximum attempts allowed
    
    # Progress tracking
    is_active = Column(Boolean, default=True)
    total_questions = Column(Integer, default=0)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    
    # Relationships
    goal = relationship("RoadmapGoal", back_populates="quizzes")
    questions = relationship("QuizQuestion", back_populates="quiz", cascade="all, delete-orphan")
    attempts = relationship("QuizAttempt", back_populates="quiz", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<Quiz(id={self.id}, goal_id={self.goal_id}, title={self.title})>"


class QuizQuestion(Base):
    """
    Stores individual quiz questions with multiple choice options.
    Each question belongs to a quiz and has exactly 4 options (A, B, C, D).
    """
    __tablename__ = "quiz_questions"
    
    id = Column(Integer, primary_key=True, index=True)
    quiz_id = Column(Integer, ForeignKey("quizzes.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Question details
    question_text = Column(Text, nullable=False)
    question_order = Column(Integer, nullable=False)  # Order within the quiz
    
    # Multiple choice options (stored as JSON array)
    options = Column(JSON, nullable=False)  # ["Option A", "Option B", "Option C", "Option D"]
    correct_answer = Column(String(1), nullable=False)  # "A", "B", "C", or "D"
    explanation = Column(Text)  # Explanation of why the correct answer is right
    
    # Question metadata
    points = Column(Integer, default=1)  # Points for correct answer
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    
    # Relationships
    quiz = relationship("Quiz", back_populates="questions")
    answers = relationship("QuizAnswer", back_populates="question", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<QuizQuestion(id={self.id}, quiz_id={self.quiz_id}, order={self.question_order})>"


class QuizAttempt(Base):
    """
    Stores user attempts at taking quizzes.
    Tracks progress, scores, and completion status.
    """
    __tablename__ = "quiz_attempts"
    
    id = Column(Integer, primary_key=True, index=True)
    quiz_id = Column(Integer, ForeignKey("quizzes.id", ondelete="CASCADE"), nullable=False, index=True)
    user_id = Column(String(255), nullable=False, index=True)  # Reference to user in main backend
    
    # Attempt details
    attempt_number = Column(Integer, nullable=False)  # 1st, 2nd, 3rd attempt, etc.
    started_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    completed_at = Column(DateTime, nullable=True)
    
    # Scoring
    total_questions = Column(Integer, default=0)
    correct_answers = Column(Integer, default=0)
    score_percentage = Column(Float, default=0.0)
    passed = Column(Boolean, default=False)
    
    # Time tracking
    time_spent_minutes = Column(Integer, default=0)
    
    # Status
    status = Column(String(20), default="in_progress")  # "in_progress", "completed", "abandoned"
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    
    # Relationships
    quiz = relationship("Quiz", back_populates="attempts")
    answers = relationship("QuizAnswer", back_populates="attempt", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<QuizAttempt(id={self.id}, quiz_id={self.quiz_id}, user_id={self.user_id}, attempt={self.attempt_number})>"


class QuizAnswer(Base):
    """
    Stores individual answers to quiz questions within an attempt.
    Links questions, attempts, and user responses.
    """
    __tablename__ = "quiz_answers"
    
    id = Column(Integer, primary_key=True, index=True)
    attempt_id = Column(Integer, ForeignKey("quiz_attempts.id", ondelete="CASCADE"), nullable=False, index=True)
    question_id = Column(Integer, ForeignKey("quiz_questions.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Answer details
    selected_answer = Column(String(1))  # "A", "B", "C", "D", or None if not answered
    is_correct = Column(Boolean, default=False)
    points_earned = Column(Integer, default=0)
    
    # Time tracking
    time_spent_seconds = Column(Integer, default=0)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    
    # Relationships
    attempt = relationship("QuizAttempt", back_populates="answers")
    question = relationship("QuizQuestion", back_populates="answers")
    
    def __repr__(self):
        return f"<QuizAnswer(id={self.id}, attempt_id={self.attempt_id}, question_id={self.question_id}, selected={self.selected_answer})>"
